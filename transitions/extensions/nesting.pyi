from ..core import Enum as Enum, EnumMeta as EnumMeta, Event as Event, EventData as EventData, Machine as Machine, MachineError as MachineError, State as State, Transition as Transition, listify as listify
from collections import defaultdict as defaultdict
from typing import Any

_LOGGER: Any
_super = super

def _build_state_list(state_tree, separator, prefix=...): ...
def _resolve_order(state_tree): ...

class FunctionWrapper:
    _func: Any
    def __init__(self, func, path) -> None: ...
    def add(self, func, path) -> None: ...
    def __call__(self, *args, **kwargs): ...

class NestedEvent(Event):
    def trigger(self, _model, _machine, *args, **kwargs): ...
    def _trigger(self, _model, _machine, _scope, *args, **kwargs): ...
    def _trigger_scoped(self, _model, _machine, *args, **kwargs): ...
    def _process(self, event_data): ...

class NestedState(State):
    separator: str
    initial: Any
    events: Any
    states: Any
    _scope: Any
    def __init__(self, name, on_enter: Any | None = ..., on_exit: Any | None = ..., ignore_invalid_triggers: Any | None = ..., initial: Any | None = ...) -> None: ...
    def add_substate(self, state) -> None: ...
    def add_substates(self, states) -> None: ...
    def scoped_enter(self, event_data, scope=...) -> None: ...
    def scoped_exit(self, event_data, scope=...) -> None: ...
    @property
    def name(self): ...

class NestedTransition(Transition):
    def _resolve_transition(self, event_data): ...
    def _change_state(self, event_data) -> None: ...
    def _enter_nested(self, root, dest, prefix_path, event_data): ...
    @staticmethod
    def _update_model(event_data, tree) -> None: ...
    def __deepcopy__(self, memo): ...

class HierarchicalMachine(Machine):
    state_cls: Any
    transition_cls: Any
    event_cls: Any
    _stack: Any
    prefix_path: Any
    scoped: Any
    def __init__(self, *args, **kwargs) -> None: ...
    _next_scope: Any
    def __call__(self, to_scope: Any | None = ...): ...
    def __enter__(self) -> None: ...
    def __exit__(self, exc_type, exc_val, exc_tb) -> None: ...
    def add_model(self, model, initial: Any | None = ...) -> None: ...
    @property
    def initial(self): ...
    _initial: Any
    @initial.setter
    def initial(self, value) -> None: ...
    def add_ordered_transitions(self, states: Any | None = ..., trigger: str = ..., loop: bool = ..., loop_includes_initial: bool = ..., conditions: Any | None = ..., unless: Any | None = ..., before: Any | None = ..., after: Any | None = ..., prepare: Any | None = ..., **kwargs) -> None: ...
    def add_states(self, states, on_enter: Any | None = ..., on_exit: Any | None = ..., ignore_invalid_triggers: Any | None = ..., **kwargs) -> None: ...
    def add_transition(self, trigger, source, dest, conditions: Any | None = ..., unless: Any | None = ..., before: Any | None = ..., after: Any | None = ..., prepare: Any | None = ..., **kwargs) -> None: ...
    def get_global_name(self, state: Any | None = ..., join: bool = ...): ...
    def get_nested_state_names(self): ...
    def get_nested_transitions(self, trigger: str = ..., src_path: Any | None = ..., dest_path: Any | None = ...): ...
    def get_nested_triggers(self, src_path: Any | None = ...): ...
    def get_state(self, state, hint: Any | None = ...): ...
    def get_states(self, states): ...
    def get_transitions(self, trigger: str = ..., source: str = ..., dest: str = ..., delegate: bool = ...): ...
    def get_triggers(self, *args): ...
    def has_trigger(self, trigger, state: Any | None = ...): ...
    def is_state(self, state_name, model, allow_substates: bool = ...): ...
    def on_enter(self, state_name, callback) -> None: ...
    def on_exit(self, state_name, callback) -> None: ...
    def set_state(self, states, model: Any | None = ...) -> None: ...
    def to_state(self, model, state_name, *args, **kwargs) -> None: ...
    def trigger_event(self, _model, _trigger, *args, **kwargs): ...
    def _add_model_to_state(self, state, model) -> None: ...
    def _add_trigger_to_model(self, trigger, model) -> None: ...
    def build_state_tree(self, model_states, separator, tree: Any | None = ...): ...
    def _get_enum_path(self, enum_state, prefix=...): ...
    def _get_state_path(self, state, prefix=...): ...
    def _check_event_result(self, res, model, trigger): ...
    def _get_trigger(self, model, trigger_name, *args, **kwargs): ...
    def _has_state(self, state, raise_error: bool = ...): ...
    def _init_state(self, state) -> None: ...
    def _recursive_initial(self, value): ...
    def _resolve_initial(self, models, state_name_path, prefix=...): ...
    def _set_state(self, state_name): ...
    def _trigger_event(self, _model, _trigger, _state_tree, *args, **kwargs): ...
